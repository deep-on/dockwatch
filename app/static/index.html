<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DockWatch</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%230d1117'/><text x='50' y='68' font-size='60' text-anchor='middle' fill='%2337d208'>üê≥</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#0d1117;--card:#161b22;--border:#30363d;--text:#c9d1d9;--text2:#8b949e;--accent:#37d208;--accent-light:#79f753;--accent-dim:#2ba806;--red:#f85149;--green:#3fb950;--yellow:#d29922;--orange:#db6d28}
body{background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Helvetica,Arial,sans-serif;font-size:14px;line-height:1.5}
.container{max-width:1400px;margin:0 auto;padding:16px}
header{display:flex;justify-content:space-between;align-items:center;padding:16px 0;border-bottom:1px solid var(--border);margin-bottom:16px}
header h1{font-size:20px;font-weight:600}
header h1 span{color:var(--accent)}
#lastUpdate{color:var(--text2);font-size:12px}
.alert-banner{background:#f8514922;border:1px solid var(--red);border-radius:8px;padding:12px 16px;margin-bottom:16px;display:none}
.alert-banner.active{display:block}
.alert-banner h3{color:var(--red);margin-bottom:4px;font-size:14px}
.alert-banner ul{list-style:none;padding:0}
.alert-banner li{color:var(--red);font-size:13px;padding:2px 0}
.cards{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:16px}
.card{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px}
.card .label{color:var(--text2);font-size:12px;text-transform:uppercase;letter-spacing:.5px}
.card .value{font-size:24px;font-weight:600;margin-top:4px}
.card .sub{color:var(--text2);font-size:12px;margin-top:2px}
.section{margin-bottom:24px}
.section h2{font-size:16px;font-weight:600;margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border)}
table{width:100%;border-collapse:collapse;background:var(--card);border:1px solid var(--border);border-radius:8px;overflow:hidden}
th,td{text-align:left;padding:8px 12px;border-bottom:1px solid var(--border);font-size:13px;white-space:nowrap}
th{background:#1c2129;color:var(--text2);font-weight:600;cursor:pointer;user-select:none}
th:hover{color:var(--accent)}
th.sorted-asc::after{content:" ‚ñ≤";color:var(--accent)}
th.sorted-desc::after{content:" ‚ñº";color:var(--accent)}
tr:last-child td{border-bottom:none}
tr:hover td{background:#1c212944}
.bar-cell{position:relative;min-width:100px}
.bar-bg{position:absolute;left:0;top:0;height:100%;opacity:.15;border-radius:2px}
.bar-text{position:relative;z-index:1}
.cpu-high{color:var(--red);font-weight:600}
.mem-high{color:var(--orange);font-weight:600}
.charts{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:16px}
.chart-box{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:16px}
.chart-box h3{font-size:13px;color:var(--text2);margin-bottom:8px}
.chart-box canvas{width:100%!important;height:200px!important}
.disk-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
.disk-item{background:var(--card);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center}
.disk-item .size{font-size:20px;font-weight:600;color:var(--accent)}
.disk-item .dlabel{color:var(--text2);font-size:12px;margin-top:4px}
.alert-log{max-height:300px;overflow-y:auto;background:var(--card);border:1px solid var(--border);border-radius:8px}
.alert-log table{margin:0;border:none}
.alert-log td{font-size:12px}
.status-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px}
.status-running{background:var(--green)}
.status-exited{background:var(--red)}
.status-paused{background:var(--yellow)}
.status-other{background:var(--text2)}
.header-right{display:flex;align-items:center;gap:12px}
.btn-icon{background:none;border:1px solid var(--border);color:var(--text2);border-radius:6px;padding:6px 10px;cursor:pointer;font-size:13px}
.btn-icon:hover{color:var(--accent);border-color:var(--accent)}
.modal-overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:100;justify-content:center;align-items:center}
.modal-overlay.active{display:flex}
.modal{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:24px;width:360px;max-width:90vw}
.modal h3{margin-bottom:16px;font-size:16px}
.modal label{display:block;color:var(--text2);font-size:12px;margin-bottom:4px;margin-top:12px}
.modal input{width:100%;padding:8px 12px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:14px;outline:none}
.modal input:focus{border-color:var(--accent)}
.modal-actions{display:flex;gap:8px;margin-top:20px;justify-content:flex-end}
.btn{padding:8px 16px;border-radius:6px;border:none;cursor:pointer;font-size:13px;font-weight:500}
.btn-primary{background:var(--accent);color:#fff}
.btn-primary:hover{opacity:.9}
.btn-cancel{background:var(--border);color:var(--text)}
.btn-cancel:hover{background:#444}
.modal .msg{margin-top:12px;font-size:13px;padding:8px;border-radius:4px;display:none}
.modal .msg.error{display:block;background:#f8514922;color:var(--red)}
.modal .msg.ok{display:block;background:#3fb95022;color:var(--green)}
.session-bar{display:flex;align-items:center;gap:16px;padding:8px 16px;background:var(--card);border:1px solid var(--border);border-radius:8px;margin-bottom:16px;font-size:12px;color:var(--text2)}
.session-bar .user-badge{color:var(--accent);font-weight:600;font-size:13px}
.session-bar .conn-badge{padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600}
.conn-ok{background:#3fb95022;color:var(--green)}
.conn-warn{background:#d2992222;color:var(--yellow)}
.conn-full{background:#f8514922;color:var(--red)}
.session-bar .ip-info{margin-left:auto}
footer{text-align:center;padding:24px 0 12px;border-top:1px solid var(--border);margin-top:24px;color:var(--text2);font-size:12px}
footer a{color:var(--accent);text-decoration:none}
footer a:hover{text-decoration:underline}
footer .logo-text{font-weight:600;font-size:13px;color:var(--text)}
.gh-badge{display:inline-flex;align-items:center;gap:4px;padding:3px 10px;background:var(--card);border:1px solid var(--border);border-radius:12px;font-size:12px;color:var(--text2);text-decoration:none;transition:border-color .2s}
.gh-badge:hover{border-color:var(--accent);color:var(--accent)}
.gh-badge b{color:var(--text);font-size:13px}
@media(max-width:768px){
  .charts{grid-template-columns:1fr}
  .cards{grid-template-columns:repeat(2,1fr)}
  table{font-size:12px}
  th,td{padding:6px 8px}
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1><img src="/static/logo.png" alt="DeepOn" style="height:28px;vertical-align:middle;margin-right:8px;border-radius:6px"><span>Dock</span>Watch</h1>
    <div class="header-right">
      <div id="lastUpdate">Loading...</div>
      <button class="btn-icon" onclick="openSettingsModal()" title="Settings">&#9881;</button>
      <button class="btn-icon" onclick="openPwModal()" title="Change Password">&#128274;</button>
    </div>
  </header>

  <div class="modal-overlay" id="pwModal">
    <div class="modal">
      <h3>Change Password</h3>
      <label>Current Password</label>
      <input type="password" id="pwCurrent" autocomplete="current-password">
      <label>New Username (optional)</label>
      <input type="text" id="pwNewUser" placeholder="Leave empty to keep current">
      <label>New Password</label>
      <input type="password" id="pwNew" autocomplete="new-password">
      <label>Confirm New Password</label>
      <input type="password" id="pwConfirm" autocomplete="new-password">
      <div class="msg" id="pwMsg"></div>
      <div class="modal-actions">
        <button class="btn btn-cancel" onclick="closePwModal()">Cancel</button>
        <button class="btn btn-primary" onclick="submitPwChange()">Change</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <h3>Settings</h3>
      <label>Max Connections <span style="font-size:11px;color:var(--text2)">(0 = unlimited)</span></label>
      <input type="number" id="setMaxConn" min="0" max="100" value="3">
      <div class="msg" id="settingsMsg"></div>
      <div class="modal-actions">
        <button class="btn btn-cancel" onclick="closeSettingsModal()">Cancel</button>
        <button class="btn btn-primary" onclick="submitSettings()">Save</button>
      </div>
    </div>
  </div>

  <div class="session-bar" id="sessionBar">
    <span>User: <span class="user-badge" id="sessionUser">-</span></span>
    <span>IP: <span id="sessionIp">-</span></span>
    <span class="conn-badge conn-ok" id="connBadge" style="cursor:pointer" onclick="openSettingsModal()" title="Click to change max connections">- / -</span>
    <span class="ip-info" id="activeIps"></span>
  </div>

  <div id="alertBanner" class="alert-banner">
    <h3>‚ö† Anomaly Detected</h3>
    <ul id="alertList"></ul>
  </div>

  <div class="cards" id="hostCards"></div>

  <div class="section">
    <h2>Containers</h2>
    <div style="overflow-x:auto">
      <table id="containerTable">
        <thead><tr>
          <th data-col="name">Name</th>
          <th data-col="status">Status</th>
          <th data-col="cpu_pct" data-type="num">CPU %</th>
          <th data-col="mem_pct" data-type="num">Memory</th>
          <th data-col="net_rx" data-type="num">Net RX</th>
          <th data-col="net_tx" data-type="num">Net TX</th>
          <th data-col="blk_read" data-type="num">Blk Read</th>
          <th data-col="blk_write" data-type="num">Blk Write</th>
          <th data-col="restart_count" data-type="num">Restarts</th>
        </tr></thead>
        <tbody id="containerBody"></tbody>
      </table>
    </div>
  </div>

  <div class="charts">
    <div class="chart-box"><h3>Container CPU %</h3><canvas id="chartCpu"></canvas></div>
    <div class="chart-box"><h3>Container Memory %</h3><canvas id="chartMem"></canvas></div>
    <div class="chart-box"><h3>Host Temperature</h3><canvas id="chartTemp"></canvas></div>
    <div class="chart-box"><h3>Host Load Average <span style="font-size:11px;color:var(--text2);font-weight:400">‚Äî CPU ÎåÄÍ∏∞ ÌîÑÎ°úÏÑ∏Ïä§ Ïàò (1min / 5min / 15min)</span></h3><canvas id="chartLoad"></canvas></div>
  </div>

  <div class="section">
    <h2>Docker Disk Usage</h2>
    <div class="disk-grid" id="diskGrid"></div>
  </div>

  <div class="section">
    <h2>Alert History (24h)</h2>
    <div class="alert-log" id="alertLog">
      <table><thead><tr><th>Time</th><th>Type</th><th>Target</th><th>Message</th></tr></thead>
      <tbody id="alertBody"></tbody></table>
    </div>
  </div>

  <footer>
    <div class="logo-text"><img src="/static/logo.png" alt="DeepOn" style="height:20px;vertical-align:middle;margin-right:6px;border-radius:4px">DockWatch</div>
    <div id="ghStats" style="margin:8px 0"></div>
    <div>Powered by <a href="https://deep-on.com" target="_blank">DeepOn Inc.</a> &middot; <a href="https://github.com/deep-on/dockwatch" target="_blank">GitHub</a> &middot; MIT License</div>
    <div style="margin-top:4px;font-size:11px;color:var(--border)">Modifications must retain the DeepOn logo and "Powered by DeepOn Inc." attribution.</div>
  </footer>
</div>

<script>
const COLORS = ['#37d208','#79f753','#58a6ff','#f85149','#d29922','#db6d28','#bc8cff','#f778ba','#79c0ff','#56d364','#e3b341','#ff7b72','#d2a8ff','#ffa657','#a5d6ff'];
let sortCol = 'cpu_pct', sortDir = -1;
let charts = {};

function fmt(b) {
  if (b == null) return '-';
  const u = ['B','KB','MB','GB','TB'];
  let i = 0;
  let v = b;
  while (v >= 1024 && i < u.length - 1) { v /= 1024; i++; }
  return v.toFixed(i > 0 ? 1 : 0) + ' ' + u[i];
}

function fmtPct(v) { return v != null ? v.toFixed(1) + '%' : '-'; }
function fmtTime(ts) { return new Date(ts * 1000).toLocaleTimeString('ko-KR', {hour:'2-digit',minute:'2-digit',second:'2-digit'}); }
function fmtDateTime(ts) { return new Date(ts * 1000).toLocaleString('ko-KR', {month:'short',day:'numeric',hour:'2-digit',minute:'2-digit',second:'2-digit'}); }

function statusDot(s) {
  const cls = s === 'running' ? 'running' : s === 'exited' ? 'exited' : s === 'paused' ? 'paused' : 'other';
  return `<span class="status-dot status-${cls}"></span>${s}`;
}

function barCell(pct, color) {
  return `<td class="bar-cell"><div class="bar-bg" style="width:${Math.min(pct,100)}%;background:${color}"></div><span class="bar-text">${fmtPct(pct)}</span></td>`;
}

function renderHostCards(host) {
  const el = document.getElementById('hostCards');
  if (!host || !host.ts) { el.innerHTML = '<div class="card"><div class="label">Status</div><div class="value">-</div></div>'; return; }
  const disk = (host.disk && host.disk[0]) || {};
  const load = host.load_avg || [0,0,0];
  const cores = host.cpu_cores || 1;
  const loadPct = Math.round(load[0] / cores * 100);
  const loadColor = loadPct > 100 ? 'var(--red)' : loadPct > 70 ? 'var(--yellow)' : 'var(--green)';
  el.innerHTML = `
    <div class="card"><div class="label">CPU Temp</div><div class="value" style="color:${host.cpu_temp > 85 ? 'var(--red)' : host.cpu_temp > 70 ? 'var(--yellow)' : 'var(--green)'}">${host.cpu_temp != null ? host.cpu_temp + '¬∞C' : 'N/A'}</div></div>
    <div class="card"><div class="label">GPU Temp</div><div class="value" style="color:${host.gpu_temp > 85 ? 'var(--red)' : host.gpu_temp > 70 ? 'var(--yellow)' : 'var(--green)'}">${host.gpu_temp != null ? host.gpu_temp + '¬∞C' : 'N/A'}</div></div>
    <div class="card"><div class="label">Disk /</div><div class="value" style="color:${disk.pct > 90 ? 'var(--red)' : disk.pct > 80 ? 'var(--yellow)' : 'var(--text)'}">${disk.pct != null ? disk.pct + '%' : 'N/A'}</div><div class="sub">${fmt(disk.used)} / ${fmt(disk.total)}</div></div>
    <div class="card" title="Load Average = CPU Ï≤òÎ¶¨ ÎåÄÍ∏∞ ÌîÑÎ°úÏÑ∏Ïä§ ÌèâÍ∑† Ïàò&#10;&#10;1min / 5min / 15min ÌèâÍ∑†&#10;${cores}ÏΩîÏñ¥ Í∏∞Ï§Ä ${loadPct}% ÏÇ¨Ïö© Ï§ë&#10;&#10;100% = CPU Ìè¨Ìôî ÏÉÅÌÉú&#10;>100% = ÌîÑÎ°úÏÑ∏Ïä§ ÎåÄÍ∏∞Ïó¥ Î∞úÏÉù (Í≥ºÎ∂ÄÌïò)"><div class="label">Load Avg <span style="font-size:10px;color:var(--text2)">(${cores} cores)</span></div><div class="value" style="color:${loadColor}">${load[0].toFixed(2)} <span style="font-size:14px;color:${loadColor}">${loadPct}%</span></div><div class="sub">5min ${load[1].toFixed(2)} / 15min ${load[2].toFixed(2)}</div></div>
  `;
}

function renderContainers(containers) {
  const tbody = document.getElementById('containerBody');
  if (!containers || !containers.length) { tbody.innerHTML = '<tr><td colspan="9" style="text-align:center;color:var(--text2)">No containers</td></tr>'; return; }

  const sorted = [...containers].sort((a, b) => {
    let va = a[sortCol], vb = b[sortCol];
    if (typeof va === 'string') return sortDir * va.localeCompare(vb);
    return sortDir * ((va || 0) - (vb || 0));
  });

  tbody.innerHTML = sorted.map(c => {
    const cpuCls = c.cpu_pct > 80 ? ' cpu-high' : '';
    const memCls = c.mem_pct > 90 ? ' mem-high' : '';
    return `<tr>
      <td><b>${c.name}</b></td>
      <td>${statusDot(c.status)}</td>
      <td class="bar-cell${cpuCls}"><div class="bar-bg" style="width:${Math.min(c.cpu_pct,100)}%;background:var(--accent)"></div><span class="bar-text">${c.cpu_pct.toFixed(1)}%</span></td>
      <td class="bar-cell${memCls}"><div class="bar-bg" style="width:${Math.min(c.mem_pct,100)}%;background:var(--green)"></div><span class="bar-text">${c.mem_pct.toFixed(1)}% (${fmt(c.mem_usage)})</span></td>
      <td>${fmt(c.net_rx)}</td>
      <td>${fmt(c.net_tx)}</td>
      <td>${fmt(c.blk_read)}</td>
      <td>${fmt(c.blk_write)}</td>
      <td>${c.restart_count}</td>
    </tr>`;
  }).join('');
}

function renderAnomalies(anomalies) {
  const banner = document.getElementById('alertBanner');
  const list = document.getElementById('alertList');
  if (!anomalies || !anomalies.length) { banner.classList.remove('active'); return; }
  banner.classList.add('active');
  list.innerHTML = anomalies.map(a => `<li>‚Ä¢ ${a.msg}</li>`).join('');
}

function renderDisk(images) {
  const el = document.getElementById('diskGrid');
  if (!images || !images.image_size) { el.innerHTML = '<div class="disk-item"><div class="dlabel">No data</div></div>'; return; }
  el.innerHTML = `
    <div class="disk-item"><div class="size">${fmt(images.image_size)}</div><div class="dlabel">Images (${images.image_count})</div></div>
    <div class="disk-item"><div class="size">${fmt(images.cache_size)}</div><div class="dlabel">Build Cache</div></div>
    <div class="disk-item"><div class="size">${fmt(images.volume_size)}</div><div class="dlabel">Volumes (${images.volume_count})</div></div>
    <div class="disk-item"><div class="size">${fmt(images.container_rw_size)}</div><div class="dlabel">Container RW</div></div>
  `;
}

function renderAlertLog(alerts) {
  const tbody = document.getElementById('alertBody');
  if (!alerts || !alerts.length) { tbody.innerHTML = '<tr><td colspan="4" style="color:var(--text2)">No recent alerts</td></tr>'; return; }
  tbody.innerHTML = alerts.map(a =>
    `<tr><td>${fmtDateTime(a.ts)}</td><td>${a.type}</td><td>${a.target}</td><td>${a.msg}</td></tr>`
  ).join('');
}

// ‚îÄ‚îÄ Chart highlight system (unified, smooth) ‚îÄ‚îÄ
let _activeChart = null;
let _activeIdx = -1;
let _animFrame = null;
// Per-chart animation state: Map<Chart, Float32Array of lerp values per dataset>
const _chartAnim = new WeakMap();

function _hexToRgba(hex, a) {
  const rr = parseInt(hex.slice(1,3),16), gg = parseInt(hex.slice(3,5),16), bb = parseInt(hex.slice(5,7),16);
  return `rgba(${rr},${gg},${bb},${a})`;
}
function _parseHex(hex) {
  return [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
}

function _setActive(chart, idx) {
  if (_activeIdx === idx && _activeChart === chart) return;
  _activeIdx = idx; _activeChart = chart;
  _startAnim();
}
function _clearActive(chart) {
  if (_activeChart !== chart) return;
  _activeIdx = -1; _activeChart = null;
  chart.canvas.style.cursor = 'default';
  _startAnim();
}

function _tickHighlight() {
  let dirty = false;
  [charts.cpu, charts.mem].forEach(chart => {
    if (!chart || !chart.data) return;
    const ds = chart.data.datasets;
    const n = ds.length;
    if (!n) return;
    // Get or create lerp array for this chart
    let arr = _chartAnim.get(chart);
    if (!arr || arr.length !== n) { arr = new Float32Array(n); _chartAnim.set(chart, arr); }
    const target = (_activeChart === chart) ? _activeIdx : -1;
    const hasTarget = target >= 0 && target < n;
    for (let i = 0; i < n; i++) {
      const goal = (hasTarget && i === target) ? 1 : 0;
      const prev = arr[i];
      arr[i] += (goal - arr[i]) * 0.15;
      if (Math.abs(arr[i] - goal) < 0.01) arr[i] = goal;
      if (Math.abs(arr[i] - prev) > 0.003) dirty = true;
      const d = ds[i], orig = d._origColor;
      if (!hasTarget) {
        d.borderColor = orig; d.borderWidth = d._origBW; d._glow = 0;
      } else if (i === target) {
        d.borderColor = orig;
        d.borderWidth = d._origBW + arr[i] * 1.5;
        d._glow = arr[i];
      } else {
        // Dim: lerp alpha from 1.0 ‚Üí 0.2 based on active item's progress
        const activeT = arr[target] || 0;
        d.borderColor = _hexToRgba(orig, 1 - activeT * 0.7);
        d.borderWidth = d._origBW; d._glow = 0;
      }
    }
  });
  if (dirty) {
    if (charts.cpu) charts.cpu.draw();
    if (charts.mem) charts.mem.draw();
    _animFrame = requestAnimationFrame(_tickHighlight);
  } else { _animFrame = null; }
}
function _startAnim() {
  if (!_animFrame) _animFrame = requestAnimationFrame(_tickHighlight);
}

// Find nearest dataset by Y value at given X position
function _findNearestDs(chart, ex, ey) {
  const area = chart.chartArea;
  if (!area) return -1;
  const labels = chart.data.labels;
  if (!labels.length) return -1;
  const xIdx = Math.round((ex - area.left) / (area.right - area.left) * (labels.length - 1));
  const ci = Math.max(0, Math.min(xIdx, labels.length - 1));
  const mouseVal = chart.scales.y.getValueForPixel(ey);
  let best = Infinity, idx = -1;
  chart.data.datasets.forEach((ds, i) => {
    const v = ds.data[ci];
    if (v != null) { const d = Math.abs(v - mouseVal); if (d < best) { best = d; idx = i; } }
  });
  return idx;
}

// Find legend item at position
function _findLegendItem(chart, ex, ey) {
  const boxes = chart.legend?.legendHitBoxes;
  if (!boxes || !boxes.length) return -1;
  // Direct hit with generous padding
  for (let i = 0; i < boxes.length; i++) {
    const b = boxes[i]; if (!b) continue;
    if (ex >= b.left - 12 && ex <= b.left + b.width + 12 &&
        ey >= b.top - 6 && ey <= b.top + b.height + 6) return i;
  }
  // Fallback: closest item on same row within legend zone
  const top = Math.min(...boxes.map(b => b.top));
  const bot = Math.max(...boxes.map(b => b.top + b.height));
  if (ey < top - 8 || ey > bot + 8) return -1;
  let best = Infinity, idx = -1;
  for (let i = 0; i < boxes.length; i++) {
    const b = boxes[i]; if (!b) continue;
    if (Math.abs(ey - (b.top + b.height / 2)) > b.height * 0.8) continue;
    const d = Math.abs(ex - (b.left + b.width / 2));
    if (d < best) { best = d; idx = i; }
  }
  return idx;
}

// Unified plugin: handles legend hover, glow drawing, legend underline
const highlightPlugin = {
  id: 'highlight',
  beforeEvent(chart, args) {
    const evt = args.event;
    if (evt.type === 'mouseout') { _clearActive(chart); return; }
    if (evt.type !== 'mousemove') return;
    const area = chart.chartArea;
    if (!area) return;

    // 1) Check legend area first
    const li = _findLegendItem(chart, evt.x, evt.y);
    if (li >= 0) {
      chart.canvas.style.cursor = 'pointer';
      _setActive(chart, li);
      args.changed = false; // prevent Chart.js default legend handling
      return;
    }

    // 2) Check chart area
    if (evt.x >= area.left && evt.x <= area.right && evt.y >= area.top && evt.y <= area.bottom) {
      const di = _findNearestDs(chart, evt.x, evt.y);
      if (di >= 0) {
        chart.canvas.style.cursor = 'crosshair';
        _setActive(chart, di);
      }
      return;
    }

    // 3) Outside both ‚Üí clear
    _clearActive(chart);
  },
  beforeDatasetDraw(chart, args) {
    const ds = chart.data.datasets[args.index];
    if (ds && ds._glow > 0.02) {
      chart.ctx.save();
      chart.ctx.shadowColor = ds._origColor || ds.borderColor;
      chart.ctx.shadowBlur = ds._glow * 18;
      chart.ctx.shadowOffsetX = 0; chart.ctx.shadowOffsetY = 0;
    }
  },
  afterDatasetDraw(chart, args) {
    const ds = chart.data.datasets[args.index];
    if (ds && ds._glow > 0.02) chart.ctx.restore();
  },
  afterDraw(chart) {
    const legend = chart.legend;
    if (!legend) return;
    const ctx = chart.ctx;
    const boxes = legend.legendHitBoxes || [];
    chart.data.datasets.forEach((ds, i) => {
      const box = boxes[i];
      if (!box || !ds) return;
      // Fade underline on highlighted item
      const gv = ds._glow || 0;
      if (gv > 0.01) {
        const [r, g, b] = _parseHex(ds._origColor || ds.borderColor);
        const tw = ctx.measureText(ds.label || '').width;
        ctx.save();
        ctx.fillStyle = `rgba(${r},${g},${b},${gv * 0.65})`;
        ctx.fillRect(box.left, box.top + box.height + 1, tw + 16, 2);
        ctx.restore();
      }
    });
  }
};

function initCharts() {
  const scaleOpts = {
    x: { display: true, ticks: { color: '#8b949e', maxTicksLimit: 6, font: { size: 10 } }, grid: { color: '#30363d33' } },
    y: { ticks: { color: '#8b949e', font: { size: 10 } }, grid: { color: '#30363d33' } }
  };

  const commonOpts = {
    responsive: true, maintainAspectRatio: false, animation: false,
    interaction: { mode: 'index', intersect: false },
    scales: scaleOpts,
    plugins: {
      legend: { labels: { color: '#c9d1d9', font: { size: 11 }, boxWidth: 12 }, onClick: () => {} },
      tooltip: {
        mode: 'index', intersect: false,
        filter(item) {
          if (_activeIdx >= 0) return item.datasetIndex === _activeIdx;
          return true; // show all when nothing highlighted
        },
        callbacks: {
          title(items) { return items.length ? items[0].label : ''; },
          label(ctx) { const v = ctx.parsed.y; return v != null ? ` ${ctx.dataset.label}: ${v.toFixed(1)}%` : ''; }
        }
      }
    }
  };

  // Non-interactive opts for temp/load
  const simpleOpts = {
    responsive: true, maintainAspectRatio: false, animation: false,
    scales: scaleOpts,
    plugins: { legend: { labels: { color: '#c9d1d9', font: { size: 11 }, boxWidth: 12 }, onClick: () => {} },
      tooltip: { mode: 'nearest', intersect: false } }
  };

  charts.cpu = new Chart(document.getElementById('chartCpu'), {
    type: 'line', data: { labels: [], datasets: [] }, plugins: [highlightPlugin],
    options: { ...commonOpts, scales: { ...scaleOpts, y: { ...scaleOpts.y, min: 0, suggestedMax: 100 } } }
  });
  charts.mem = new Chart(document.getElementById('chartMem'), {
    type: 'line', data: { labels: [], datasets: [] }, plugins: [highlightPlugin],
    options: { ...commonOpts, scales: { ...scaleOpts, y: { ...scaleOpts.y, min: 0, suggestedMax: 100 } } }
  });
  charts.temp = new Chart(document.getElementById('chartTemp'), {
    type: 'line', data: { labels: [], datasets: [] },
    options: { ...simpleOpts, scales: { ...scaleOpts, y: { ...scaleOpts.y, min: 0 } } }
  });
  charts.load = new Chart(document.getElementById('chartLoad'), {
    type: 'line', data: { labels: [], datasets: [] },
    options: simpleOpts
  });
}

// Accumulate chart data points client-side (last 60 points = ~10 min at 10s)
const MAX_POINTS = 60;
let chartData = { cpu: {}, mem: {}, temp: { cpu: [], gpu: [] }, load: { l1: [], l5: [], l15: [] }, labels: [] };

function updateCharts(containers, host) {
  if (!containers) return;
  const now = fmtTime(Date.now() / 1000);
  chartData.labels.push(now);
  if (chartData.labels.length > MAX_POINTS) chartData.labels.shift();

  for (const c of containers) {
    if (!chartData.cpu[c.name]) { chartData.cpu[c.name] = []; chartData.mem[c.name] = []; }
    chartData.cpu[c.name].push(c.cpu_pct);
    chartData.mem[c.name].push(c.mem_pct);
    if (chartData.cpu[c.name].length > MAX_POINTS) { chartData.cpu[c.name].shift(); chartData.mem[c.name].shift(); }
  }

  if (host) {
    chartData.temp.cpu.push(host.cpu_temp);
    chartData.temp.gpu.push(host.gpu_temp);
    const load = host.load_avg || [0,0,0];
    chartData.load.l1.push(load[0]);
    chartData.load.l5.push(load[1]);
    chartData.load.l15.push(load[2]);
    if (chartData.temp.cpu.length > MAX_POINTS) {
      chartData.temp.cpu.shift(); chartData.temp.gpu.shift();
      chartData.load.l1.shift(); chartData.load.l5.shift(); chartData.load.l15.shift();
    }
  }

  // CPU chart
  const names = Object.keys(chartData.cpu);
  charts.cpu.data.labels = [...chartData.labels];
  charts.cpu.data.datasets = names.map((n, i) => {
    const color = COLORS[i % COLORS.length];
    return { label: n, data: [...chartData.cpu[n]], borderColor: color, _origColor: color,
      borderWidth: 1.5, _origBW: 1.5, pointRadius: 0, tension: 0.3, fill: false };
  });
  charts.cpu.update('none');
  if (_activeChart === charts.cpu) _startAnim();

  // Memory chart
  charts.mem.data.labels = [...chartData.labels];
  charts.mem.data.datasets = names.map((n, i) => {
    const color = COLORS[i % COLORS.length];
    return { label: n, data: [...chartData.mem[n]], borderColor: color, _origColor: color,
      borderWidth: 1.5, _origBW: 1.5, pointRadius: 0, tension: 0.3, fill: false };
  });
  charts.mem.update('none');
  if (_activeChart === charts.mem) _startAnim();

  // Temperature chart
  charts.temp.data.labels = [...chartData.labels];
  charts.temp.data.datasets = [
    { label: 'CPU', data: [...chartData.temp.cpu], borderColor: '#f85149', borderWidth: 2, pointRadius: 0, tension: 0.3, spanGaps: true },
    { label: 'GPU', data: [...chartData.temp.gpu], borderColor: '#d29922', borderWidth: 2, pointRadius: 0, tension: 0.3, spanGaps: true }
  ];
  charts.temp.update('none');

  // Load chart
  charts.load.data.labels = [...chartData.labels];
  charts.load.data.datasets = [
    { label: '1 min', data: [...chartData.load.l1], borderColor: '#58a6ff', borderWidth: 2, pointRadius: 0, tension: 0.3 },
    { label: '5 min', data: [...chartData.load.l5], borderColor: '#3fb950', borderWidth: 2, pointRadius: 0, tension: 0.3 },
    { label: '15 min', data: [...chartData.load.l15], borderColor: '#d29922', borderWidth: 2, pointRadius: 0, tension: 0.3 }
  ];
  charts.load.update('none');
}

// Table sorting
document.querySelectorAll('#containerTable th').forEach(th => {
  th.addEventListener('click', () => {
    const col = th.dataset.col;
    if (sortCol === col) sortDir *= -1;
    else { sortCol = col; sortDir = th.dataset.type === 'num' ? -1 : 1; }
    document.querySelectorAll('#containerTable th').forEach(h => h.classList.remove('sorted-asc','sorted-desc'));
    th.classList.add(sortDir === 1 ? 'sorted-asc' : 'sorted-desc');
    if (window._lastContainers) renderContainers(window._lastContainers);
  });
});

function renderSession(s) {
  if (!s) return;
  document.getElementById('sessionUser').textContent = s.user || '-';
  document.getElementById('sessionIp').textContent = s.ip || '-';
  const badge = document.getElementById('connBadge');
  const cnt = s.active_connections || 0;
  const max = s.max_connections || 0;
  badge.textContent = max > 0 ? `${cnt} / ${max}` : `${cnt}`;
  badge.className = 'conn-badge ' + (max <= 0 ? 'conn-ok' : cnt >= max ? 'conn-full' : cnt >= max - 1 ? 'conn-warn' : 'conn-ok');
  const ips = (s.active_ips || []).filter(ip => ip !== s.ip);
  document.getElementById('activeIps').textContent = ips.length ? 'Others: ' + ips.join(', ') : '';
}

async function refresh() {
  try {
    const [cur, alerts, session] = await Promise.all([
      fetch('/api/current').then(r => r.json()),
      fetch('/api/alerts?hours=24').then(r => r.json()),
      fetch('/api/session').then(r => r.json())
    ]);
    document.getElementById('lastUpdate').textContent = 'Updated: ' + fmtTime(Date.now() / 1000);
    renderSession(session);
    renderHostCards(cur.host || {});
    window._lastContainers = cur.containers;
    renderContainers(cur.containers || []);
    renderAnomalies(cur.anomalies || []);
    renderDisk(cur.images || {});
    renderAlertLog(alerts || []);
    updateCharts(cur.containers, cur.host);
  } catch (e) {
    document.getElementById('lastUpdate').textContent = 'Error: ' + e.message;
  }
}

function openPwModal() {
  document.getElementById('pwModal').classList.add('active');
  document.getElementById('pwCurrent').value = '';
  document.getElementById('pwNewUser').value = '';
  document.getElementById('pwNew').value = '';
  document.getElementById('pwConfirm').value = '';
  const msg = document.getElementById('pwMsg');
  msg.className = 'msg'; msg.textContent = '';
  document.getElementById('pwCurrent').focus();
}

function closePwModal() {
  document.getElementById('pwModal').classList.remove('active');
}

document.getElementById('pwModal').addEventListener('click', function(e) {
  if (e.target === this) closePwModal();
});

async function submitPwChange() {
  const msg = document.getElementById('pwMsg');
  const curPw = document.getElementById('pwCurrent').value;
  const newUser = document.getElementById('pwNewUser').value.trim();
  const newPw = document.getElementById('pwNew').value;
  const confirmPw = document.getElementById('pwConfirm').value;

  if (!newPw) { msg.className = 'msg error'; msg.textContent = 'New password is required.'; return; }
  if (newPw !== confirmPw) { msg.className = 'msg error'; msg.textContent = 'Passwords do not match.'; return; }
  if (newPw.length < 4) { msg.className = 'msg error'; msg.textContent = 'Password must be at least 4 characters.'; return; }

  try {
    const resp = await fetch('/api/change-password', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ current_password: curPw, new_username: newUser, new_password: newPw })
    });
    const data = await resp.json();
    if (data.ok) {
      msg.className = 'msg ok';
      msg.textContent = 'Password changed. Reloading...';
      setTimeout(() => location.reload(), 1500);
    } else {
      msg.className = 'msg error';
      msg.textContent = data.error || 'Failed to change password.';
    }
  } catch (e) {
    msg.className = 'msg error';
    msg.textContent = 'Network error: ' + e.message;
  }
}

function openSettingsModal() {
  document.getElementById('settingsModal').classList.add('active');
  const msg = document.getElementById('settingsMsg');
  msg.className = 'msg'; msg.textContent = '';
  fetch('/api/settings').then(r => r.json()).then(data => {
    document.getElementById('setMaxConn').value = data.max_connections || 0;
  });
  document.getElementById('setMaxConn').focus();
}

function closeSettingsModal() {
  document.getElementById('settingsModal').classList.remove('active');
}

document.getElementById('settingsModal').addEventListener('click', function(e) {
  if (e.target === this) closeSettingsModal();
});

async function submitSettings() {
  const msg = document.getElementById('settingsMsg');
  const maxConn = parseInt(document.getElementById('setMaxConn').value, 10);
  if (isNaN(maxConn) || maxConn < 0 || maxConn > 100) {
    msg.className = 'msg error'; msg.textContent = 'Value must be 0-100 (0=unlimited)'; return;
  }
  try {
    const resp = await fetch('/api/settings', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ max_connections: maxConn })
    });
    const data = await resp.json();
    if (data.ok) {
      msg.className = 'msg ok';
      msg.textContent = 'Settings saved.';
      setTimeout(() => closeSettingsModal(), 1000);
    } else {
      msg.className = 'msg error';
      msg.textContent = data.error || 'Failed to save settings.';
    }
  } catch (e) {
    msg.className = 'msg error';
    msg.textContent = 'Network error: ' + e.message;
  }
}

initCharts();

// ‚îÄ‚îÄ GitHub stats with warm messages ‚îÄ‚îÄ
async function fetchGhStats() {
  try {
    const r = await fetch('/api/github-stats');
    const d = await r.json();
    const el = document.getElementById('ghStats');
    const stars = d.stars || 0;
    const forks = d.forks || 0;
    const watchers = d.watchers || 0;

    // Warm message based on star count
    let msg = '';
    if (stars === 0) msg = 'Be the first to star us ‚Äî your support means the world!';
    else if (stars < 10) msg = `${stars} star${stars>1?'s':''} so far ‚Äî every star fuels our motivation!`;
    else if (stars < 50) msg = `${stars} stars ‚Äî thank you, early supporters!`;
    else if (stars < 100) msg = `${stars} stars ‚Äî growing steadily. We appreciate you!`;
    else if (stars < 500) msg = `${stars} stars ‚Äî word is spreading!`;
    else if (stars < 1000) msg = `${stars} stars ‚Äî the community is amazing!`;
    else msg = `${stars.toLocaleString()} stars ‚Äî wow, we're blown away!`;

    el.innerHTML = `
      <div style="margin-bottom:6px;font-size:12px;color:var(--text2)">${msg}</div>
      <a class="gh-badge" href="https://github.com/${d.repo}" target="_blank" title="Star us on GitHub">&#11088; <b>${stars}</b> Stars</a>
      <a class="gh-badge" href="https://github.com/${d.repo}/network/members" target="_blank">&#127860; <b>${forks}</b> Forks</a>
      <a class="gh-badge" href="https://github.com/${d.repo}/watchers" target="_blank">&#128064; <b>${watchers}</b> Watching</a>
    `;
  } catch(e) {}
}

refresh();
fetchGhStats();
setInterval(refresh, 10000);
setInterval(fetchGhStats, 600000); // refresh GitHub stats every 10 min
</script>
</body>
</html>
